# -*- coding: utf-8 -*-
# @Author: gunjianpan
# @Date:   2024-01-07 12:09:47
# @Last Modified by:   gunjianpan
# @Last Modified time: 2024-01-07 12:09:58

"""
100154. 执行操作后的最大分割数量 显示英文描述 
通过的用户数0
尝试过的用户数16
用户总通过次数0
用户总提交次数39
题目难度Hard
给你一个下标从 0 开始的字符串 s 和一个整数 k。

你需要执行以下分割操作，直到字符串 s 变为 空：

选择 s 的最长前缀，该前缀最多包含 k 个 不同 字符。
删除 这个前缀，并将分割数量加一。如果有剩余字符，它们在 s 中保持原来的顺序。
执行操作之 前 ，你可以将 s 中 至多一处 下标的对应字符更改为另一个小写英文字母。

在最优选择情形下改变至多一处下标对应字符后，用整数表示并返回操作结束时得到的最大分割数量。

 

示例 1：

输入：s = "accca", k = 2
输出：3
解释：在此示例中，为了最大化得到的分割数量，可以将 s[2] 改为 'b'。
s 变为 "acbca"。
按照以下方式执行操作，直到 s 变为空：
- 选择最长且至多包含 2 个不同字符的前缀，"acbca"。
- 删除该前缀，s 变为 "bca"。现在分割数量为 1。
- 选择最长且至多包含 2 个不同字符的前缀，"bca"。
- 删除该前缀，s 变为 "a"。现在分割数量为 2。
- 选择最长且至多包含 2 个不同字符的前缀，"a"。
- 删除该前缀，s 变为空。现在分割数量为 3。
因此，答案是 3。
可以证明，分割数量不可能超过 3。
示例 2：

输入：s = "aabaab", k = 3
输出：1
解释：在此示例中，为了最大化得到的分割数量，可以保持 s 不变。
按照以下方式执行操作，直到 s 变为空： 
- 选择最长且至多包含 3 个不同字符的前缀，"aabaab"。
- 删除该前缀，s 变为空。现在分割数量为 1。
因此，答案是 1。
可以证明，分割数量不可能超过 1。
示例 3：

输入：s = "xxyz", k = 1
输出：4
解释：在此示例中，为了最大化得到的分割数量，可以将 s[1] 改为 'a'。
s 变为 "xayz"。
按照以下方式执行操作，直到 s 变为空：
- 选择最长且至多包含 1 个不同字符的前缀，"xayz"。
- 删除该前缀，s 变为 "ayz"。现在分割数量为 1。
- 选择最长且至多包含 1 个不同字符的前缀，"ayz"。
- 删除该前缀，s 变为 "yz"，现在分割数量为 2。
- 选择最长且至多包含 1 个不同字符的前缀，"yz"。
- 删除该前缀，s 变为 "z"。现在分割数量为 3。
- 选择最且至多包含 1 个不同字符的前缀，"z"。
- 删除该前缀，s 变为空。现在分割数量为 4。
因此，答案是 4。
可以证明，分割数量不可能超过 4。
 

提示：

1 <= s.length <= 104
s 只包含小写英文字母。
1 <= k <= 26
"""
class Solution:
    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:
        if k == 26:
            return 1
        A = list(ord(c) - ord('a') for c in s)
        n = len(A)

        @cache
        def dp(i, s, t, cur):
            if i == n:
                return cur
            s2 = s | (1 << A[i])
            res = 0
            if s2.bit_count() > k:
                res = max(res, dp(i + 1, 1 << A[i], t, cur + 1))
            else:
                res = max(res, dp(i + 1, s2, t, cur))
            if t > 0:
                for j in range(26):
                    s2 = s | (1 << j)
                    if s2.bit_count() > k:
                        res = max(res, dp(i + 1, 1 << j, t - 1, cur + 1))
                    else:
                        res = max(res, dp(i + 1, s2, t - 1, cur))
            return res
        return dp(0, 0, 1, 1)